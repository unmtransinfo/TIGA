---
title: "GWAS Explorer (GWAX)"
author: "Jeremy Yang"
output:
  html_document:
    number_sections: yes
    toc: yes
---

# Introduction

Genome wide association studies (GWAS) can reveal important genotype to phenotype
associations, however, data quality and interpretability issues must be addressed.
The GWAX approach enables rational ranking, filtering and interpretation of GWAS
via metrics, methods, and interactive visualization.  Each inferred gene-to-trait
association is evaluated for confidence and relevance, with scores solely derived
from aggregated statistics, linking a protein-coding gene and phenotype. Applicability
and thresholds will depend on use cases.

* Updated to [GWAS Catalog](https://www.ebi.ac.uk/gwas/) v1.0.2, Sept 30, 2018.
* Workflow designed for integration with TCRD & Pharos
* RCRAS, Relative Citation Ratio (RCR) Aggregated Score based on iCite-RCR.
* Confidence higher (and provenance/accountability) for `mapped` over `reported` SNP-gene associations.
* Prototype RShiny app: <http://unmtid-shinyapps.net/gwax/>

Issues:

* BETA not comparable for different units, thus currently only OR used for GWAX.
* Linkage Disequilibrium (LD). Should we use [SNPsnap](https://www.broadinstitute.org/mpg/snap/ldsearch.php) to identify LD associates?

To-do:

* Confidence scoring for SNP-gene mappings.
* EFO subclass related studies, linking, aggregation, scoring.
* EFO to DOID linking, aggregation, scoring.
* Polygenic diseases/traits: Filter if less suitable for GWAS-based drug target discovery use cases.
* Scoring for polygenicity?
* Scoring for pleiotropy?

## About NHGRI-EBI GWAS Catalog

GWAS Catalog (<http://www.ebi.ac.uk/gwas/>) studies each have a `study_accession`.
Also are associated with a publication (PubMedID), but not uniquely.
See <https://www.ebi.ac.uk/gwas/docs/fileheaders>.

Some key definitions:

	`MAPPED GENE(S)`: Gene(s) mapped to the strongest SNP. If the SNP is located
	within a gene, that gene is listed. If the SNP is intergenic, the upstream
	and downstream genes are listed, separated by a hyphen.

	`REPORTED GENE(S)`*: Gene(s) reported by author
	
	`OR or BETA`: Reported odds ratio or beta-coefficient associated with
	strongest SNP risk allele. Note that if an OR <1 is reported this is
	inverted, along with the reported allele, so that all ORs included in
	the Catalog are >1. Appropriate unit and increase/decrease are included
	for beta coefficients.


* Welter D, MacArthur J, Morales J, Burdett T, Hall P, Junkins H,
Klemm A, Flicek P, Manolio T, Hindorff L, and Parkinson H. The NHGRI
GWAS Catalog, a curated resource of SNP-trait associations. Nucleic
Acids Research, 2014, Vol. 42 (Database issue): D1001-D1006.


```{r echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
base::date()
```

```{r message=FALSE, warning=FALSE}
library(readr, quietly=T)
library(data.table, quietly=T)
library(plotly, quietly=T)
```

# Read files

From GWAS Catalog, TCRD, and EFO.

```{r}
ifile_gwas <- "data/gwascat_gwas.tsv"
ifile_assn <- "data/gwascat_assn.tsv"
ifile_snp2gene <- "data/gwascat_snp2gene.tsv"
ifile_trait <- "data/gwascat_trait.tsv"
ifile_icite <- "data/gwascat_icite.tsv"
ifile_tcrd <- "data/tcrd_targets.csv"
ifile_efo <- "data/efo.tsv"
ifile_efo2do <- "data/ebi-oxo_efo2doid_mappings_maxd-2.tsv"
ifile_efo_gwas <- "data/efo_sub_gwas.tsv"
gt_statsfile <- "data/gt_stats.tsv.gz"
gwas <- read_delim(ifile_gwas, "\t", col_types=cols(.default=col_character(), 
    DATE=col_date(format="%Y-%m-%d"), DATE_ADDED_TO_CATALOG=col_date(format="%Y-%m-%d"),
    ASSOCIATION_COUNT=col_integer(), study_N=col_integer()))
setDT(gwas)
assn <- read_delim(ifile_assn, "\t", col_types=cols(.default=col_character(), 
    DATE=col_date(format="%Y-%m-%d"), DATE_ADDED_TO_CATALOG=col_date(format="%Y-%m-%d")))
setDT(assn)
snp2gene <- read_delim(ifile_snp2gene, "\t", col_types=cols(.default=col_character(),
    REPORTED_OR_MAPPED=col_factor(c("r","m","md","mu"))))
setDT(snp2gene)
trait <- read_delim(ifile_trait, "\t", col_types=cols(.default=col_character()))
setDT(trait)
tcrd <- read_csv(ifile_tcrd, col_types=cols(.default=col_character()))
setDT(tcrd)
```

# Genome Wide Association Studies (GWAS)

### Counts by year

```{r}
sprintf("Studies total: %d ; accessions: %d ; traits: %d ; PMIDs: %d", nrow(gwas), uniqueN(gwas$STUDY_ACCESSION), uniqueN(gwas$DISEASE_TRAIT), uniqueN(gwas$PUBMEDID))
gwas[, `:=`(YEAR = format(DATE,"%Y"), PLATFORM = sub("[, ].*$", "", `PLATFORM_[SNPS_PASSING_QC]`))]
gwas_platforms <- gwas[, .(.N), by=c("YEAR", "PLATFORM")]
setorder(gwas_platforms, YEAR, PLATFORM)
plot_ly(type="bar", data=gwas_platforms[, .(N_gwas = sum(N)), by=YEAR], x=~YEAR, y=~N_gwas) %>%
  layout(title="GWAS Catalog Counts", 
         margin=list(t=120), font=list(family="monospace", size=18)) %>%
  add_annotations(text=sprintf("N_study = %d", nrow(gwas)), showarrow=F, x=0.1, y=1.0, xref="paper", yref="paper")
```
### Laboratory platforms

Grouped by vendor (first in list if multiple), though technologies may have evolved for a given
vendor.

```{r}
gwas_platforms_cast <- dcast(gwas_platforms, YEAR ~ PLATFORM, value.var="N", fill=0)
plot_ly(gwas_platforms_cast, x=~YEAR, y=~NR, name="NR",
                type="scatter", mode="markers", fill="tonexty") %>%
  add_trace(y = ~Perlegen, name="Perlegen") %>%
  add_trace(y = ~Affymetrix, name="Affymetrix") %>%
  add_trace(y = ~Illumina, name="Illumina") %>%
  layout(title = 'GWAS counts by year &amp; vendor',
         xaxis = list(title="", showgrid=F),
         yaxis = list(title="N_study", showgrid=F),
         margin = list(t=100, l=100),
         font = list(family="monospace", size=18),
         legend = list(x=.1, y=.9), showlegend=T)
```

### Sample size

Statistical power and strength of evidence is dependent on size of the cohort.

```{r}
anns <- c(sprintf("median: %d", median(gwas$study_N)),
          sprintf("mean: %.1f", mean(gwas$study_N)),
          sprintf("range: [%d-%d]", min(gwas$study_N), max(gwas$study_N)))
plot_ly(gwas, type="histogram", x=~study_N) %>%
  layout(title="GWAS sample sizes",
         xaxis=list(title="Sample size"), yaxis=list(title="N_Studies"),
         margin = list(t=100, l=100),
         font = list(family="monospace", size=18)) %>%
  add_annotations(text=paste0(anns, collapse="<br>"), showarrow=F, x=0.5, y=.9, xref="paper", yref="paper")
```

### Journals

```{r}
gwas_journals <- gwas[, .(N_gwas = .N, N_pmid = uniqueN(PUBMEDID), N_assn = sum(ASSOCIATION_COUNT)), by="JOURNAL"]
setorder(gwas_journals, -N_gwas)
knitr::kable(gwas_journals[1:12], caption="Top journals by N_gwas")
```

# iCite Relative Citation Ratio (RCR)

iCite annotations from iCite API, with all PMIDs from GWASCatalog.
New publications may lack iCite RCR. Should we impute RCR=median as reasonable prior?

```{r warning=FALSE}
icite <- read_delim(ifile_icite, "\t", col_types=cols(.default=col_character(),
                       relative_citation_ratio=col_double(), field_citation_rate=col_double(),
                       citation_count=col_integer(), nih_percentile=col_double(),
                       expected_citations_per_year=col_double(), citations_per_year=col_double(),
                       year=col_integer()))
gwas_icite <- merge(gwas[, .(STUDY_ACCESSION, PUBMEDID)], icite, by.x="PUBMEDID", by.y="pmid", all.x=T, all.y=F)
qtl <- quantile(gwas_icite$relative_citation_ratio, seq(0,1,.1), na.rm=T)
anns <- c(sprintf("N_pmid = %d", nrow(gwas_icite)), sprintf("mean = %.1f ; median = %.1f ; max = %.1f", mean(gwas_icite$relative_citation_ratio, na.rm=T), median(gwas_icite$relative_citation_ratio, na.rm=T), max(gwas_icite$relative_citation_ratio, na.rm=T)), sprintf("90%%ile = %.1f", qtl["90%"]), ("(Plot truncated at 25.)"))
plot_ly(gwas_icite, x=~relative_citation_ratio, type="histogram") %>%
  layout(title = 'iCite Relative Citation Ratio (RCR)<br>Distribution for GWAS publications',
         xaxis = list(title="RCR", type="normal", range=c(0,25), showgrid=T),
         yaxis = list(title="", showgrid=T),
         margin = list(t=100, l=100, r=100),
         font = list(family="monospace", size=18)) %>%
  add_annotations(text=paste0(anns, collapse="<br>"), showarrow=F, x=0.5, y=.9, xref="paper", yref="paper")
anns
```

```{r warning=FALSE}
gwas_icite[!(journal %in% gwas_icite[, .N, by=journal][order(-N)][1:12, journal]), journal := "Other"]
wordwrap <- function(v, len) sapply(sapply(v, strwrap, len), paste, collapse="<br>")
plot_ly(gwas_icite, x=~year, y=~relative_citation_ratio, color = ~journal, type="box",
        text=sprintf("%s: %s, <i>%s</i> (%d)", gwas_icite$PUBMEDID, wordwrap(gwas_icite$title, 40), gwas_icite$journal, gwas_icite$year)) %>%
  layout(title = 'iCite Relative Citation Ratio<br>GWAS Publications',
         xaxis = list(title="", showgrid=F, dtick=1, tickangle=45, tickfont=list(size=14)),
         yaxis = list(title="RCR", range=c(0,25), showgrid=T),
         margin = list(t=100, l=100, r=100),
         font = list(family="monospace", size=18),
         boxmode="group",
         legend=list(x=1, y=.9, font=list(size=12)), showlegend=T)
```

# Associations (SNP to trait)

```{r}
sprintf("Associations total: %d ; SNPs: %d ; traits: %d ; PMIDs: %d", nrow(assn), uniqueN(assn$SNPS), uniqueN(assn$DISEASE_TRAIT), uniqueN(assn$PUBMEDID))
```


# SNP to gene mappings

* `GSYMB`, `MAPPED_GENE` fields may include chromosomal locations or be "intergenic".
* Chromosomal locations (LOC*) may be non-coding RNA, etc.
* Mappings within gene stronger associations than upstream or downstream.

```{r}
sprintf("snp2gene: total associations: %d ; studies: %d ; snps: %d ; genes: %d ; intergenic associations: %d ; chromosomal location associations: %d",
        nrow(snp2gene), uniqueN(snp2gene$STUDY_ACCESSION), uniqueN(snp2gene$SNP), 
        uniqueN(snp2gene[!grepl("^LOC", GSYMB) & GSYMB != "intergenic", .(GSYMB)]),
        nrow(snp2gene[GSYMB=="intergenic"]), nrow(snp2gene[grepl("^LOC", GSYMB)]))
snp2gene[, REPORTED_OR_MAPPED := sub('^r$', 'reported', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^m$', 'mapped_within', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^mu$', 'mapped_upstream', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^md$', 'mapped_downstream', REPORTED_OR_MAPPED)]
snp2gene_counts <- snp2gene[, .(.N), by="REPORTED_OR_MAPPED"]
knitr::kable(snp2gene_counts)
```


# Gene counts


```{r}
names(trait) <- c("STUDY_ACCESSION","TRAIT","TRAIT_URI")
trait <- trait[!is.na(trait$TRAIT_URI)]
trait$TRAIT <- iconv(trait$TRAIT, from="latin1", to="UTF-8")
trait[, trait_id := sub("^.*/", "", TRAIT_URI)]
sprintf("Studies: %d", uniqueN(assn$STUDY_ACCESSION))
sprintf("MAPPED_GENE values: %d", uniqueN(assn$MAPPED_GENE))
#
assn_reported <- assn[, .(STUDY_ACCESSION, `REPORTED_GENE(S)`)]
assn_reported <- unique(assn_reported[, list(GENE=unlist(strsplit(`REPORTED_GENE(S)`, ", *"))), by=STUDY_ACCESSION])
sprintf("REPORTED_GENE values: %d", uniqueN(assn_reported$GENE))
#
gsyms_tcrd <- unique(tcrd$protein_sym)
sprintf("TCRD targets: %d ; geneSymbols: %d", nrow(tcrd), length(gsyms_tcrd))
gsyms_gwax <- unique(snp2gene$GSYMB)
gsyms_common <- intersect(gsyms_gwax, gsyms_tcrd)
sprintf("GSYMBs mapped to TCRD: %d", length(gsyms_common))
tcrd <- merge(tcrd, data.table(gsym=gsyms_gwax, in_gwascat=rep(T, length(gsyms_gwax))),
	by.x="protein_sym", by.y="gsym", all.x=T, all.y=F)
tcrd$in_gwascat[is.na(tcrd$in_gwascat)] <- F
tcrd$idg2 <- as.logical(tcrd$idg2)
t2 <- table(tcrd$tdl[tcrd$in_gwascat])
sprintf("%s: %d", names(t2), t2)
```

# Gene-SNP-Study-Trait (G2T) associations

g2t should have one row for each gene-snp-study-trait association.

```{r}
g2t <- unique(snp2gene[, .(GSYMB, SNP, STUDY_ACCESSION)])
g2t <- merge(g2t, assn[, .(SNPS, STUDY_ACCESSION, PVALUE_MLOG, OR_or_BETA, oddsratio, beta)], 
	all.x=T, all.y=F, by.x=c("SNP", "STUDY_ACCESSION"), by.y=c("SNPS", "STUDY_ACCESSION"))

g2t <- merge(g2t, trait, all.x=F, all.y=F, by="STUDY_ACCESSION", allow.cartesian=T)
g2t <- g2t[!is.na(GSYMB)]
g2t <- g2t[!is.na(OR_or_BETA)]
g2t <- g2t[!grepl("(^LOC|^intergenic)", GSYMB)]

sprintf("GTs with pvalue_mlog, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$PVALUE_MLOG),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$PVALUE_MLOG)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$PVALUE_MLOG)]))
sprintf("GTs with or_or_beta, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$OR_or_BETA),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$OR_or_BETA)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$OR_or_BETA)]))
sprintf("GTs with oddsratio, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$oddsratio),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$oddsratio)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$oddsratio)]))
sprintf("GTs with beta, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$beta),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$beta)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$beta)]))
```

# Traits and EFO

EFO = Experimental Factor Ontology. Includes Orphanet, PO, Mondo and Uberon classes.
TSV from source OWL. 

```{r warning=FALSE}
efo <- read_delim(ifile_efo, "\t", col_types=cols(.default=col_character()))
setDT(efo)
efo_classes <- efo[node_or_edge=="node"][, `:=`(node_or_edge=NULL, source=NULL, target=NULL)]
sprintf("EFO total classes: %d", uniqueN(efo_classes$uri))
efo_classes[, in_gwascat := as.logical(uri %in% trait$TRAIT_URI)]
efo_counts <- efo_classes[, Ontology := sub("_.*$", "", id)][, .(N_in_gwas = sum(in_gwascat), N_total = .N), by=Ontology][order(-N_in_gwas)]
knitr::kable(efo_counts[1:5], caption="EFO sources, top 5")
```

## GWAS trait-subclass relationships 

```{r}
efo_sub <- efo[node_or_edge=="edge"][, `:=`(node_or_edge=NULL, id=NULL, comment=NULL, uri=NULL)]
sprintf("EFO classes: %d ; total subclass relationships: %d", uniqueN(efo$uri), nrow(efo_sub))
efo_sub[, source_in_gwas := (source %in% trait$TRAIT_URI)]
efo_sub[, target_in_gwas := (target %in% trait$TRAIT_URI)]
efo_sub <- efo_sub[(source_in_gwas) & (target_in_gwas)]
efo_sub[, `:=`(source_in_gwas=NULL, target_in_gwas=NULL, label=NULL)]
setnames(efo_sub, old=c("source", "target"), new=c("trait_uri", "subclass_uri"))
trait_counts <- trait[, .(N_gwas = .N), by=c("TRAIT_URI", "TRAIT")]
efo_sub <- merge(efo_sub, trait_counts[, .(TRAIT_URI, trait_N_gwas=N_gwas, trait_name=TRAIT)], by.x="trait_uri", by.y="TRAIT_URI", all.x=T, all.y=F)
efo_sub <- merge(efo_sub, trait_counts[, .(TRAIT_URI, subclass_N_gwas=N_gwas, subclass_name=TRAIT)], by.x="subclass_uri", by.y="TRAIT_URI", all.x=T, all.y=F)
efo_sub[, `:=`(trait_id = sub("^.*/", "", trait_uri), subclass_id = sub("^.*/", "", subclass_uri))]
efo_sub <- efo_sub[, .(trait_id, trait_name, subclass_id, subclass_name, trait_N_gwas, subclass_N_gwas)]
sprintf("GWAS trait-subclass pairs: %d", nrow(efo_sub))
setorder(efo_sub, -trait_N_gwas, -subclass_N_gwas)
knitr::kable(efo_sub[1:24], caption="Top EFO trait-subclass pairs")
```

## GWAS studies related by EFO subclass links.

```{r}
efo_gwas <- read_delim(ifile_efo_gwas, "\t", col_types=cols(.default=col_character()))
setDT(efo_gwas)
sprintf("GWAS studies related by EFO-subclass: %d", uniqueN(union(efo_gwas$trait_uri, efo_gwas$subclass_uri)))
```

## EFO to DOID (Disease Ontology ID)

From EBI Ontology Xref Service (OxO).
One-to-many and many-to-one mappings exist.
Keep only closest mappings, maximum distance=2.

```{r}
efo2do <- read_delim(ifile_efo2do, "\t", col_types=cols(.default=col_character()))
setDT(efo2do)
efo2do[, `:=`(curie_id = sub(":", "_", curie_id, fixed=T), mapped_curie = sub(":", "_", mapped_curie, fixed=T), mapping_source_prefix = NULL, mapping_target_prefix = NULL)]
setnames(efo2do, old=c("curie_id", "label",  "mapped_curie", "mapped_label"), new=c("efo_id", "efo_name", "do_id", "doid_name"))
efo2do <- efo2do[, .SD[distance == min(distance)], by=c("efo_id", "do_id")] #keep only closest mappings
gwas_efo_ids <- unique(sub("^.*/", "", efo_gwas$trait_uri))
efo2do_gwas <- efo2do[(efo_id %in% gwas_efo_ids)]
setorder(efo2do_gwas, efo_id, do_id)
sprintf("GWAS EFO_IDs (Total): %d", length(gwas_efo_ids))
sprintf("GWAS EFO_ID to DO_ID mappings (distance<=2): EFO_IDs: %d, DO_IDs: %d", 
        uniqueN(efo2do_gwas[, efo_id]), uniqueN(efo2do_gwas[, do_id]))
sprintf("GWAS EFO_ID to DO_ID mappings (efo_name=doid_name): EFO_IDs: %d, DO_IDs: %d", 
        uniqueN(efo2do_gwas[efo_name==doid_name, efo_id]), uniqueN(efo2do_gwas[efo_name==doid_name, do_id]))
sprintf("GWAS EFO_ID to DO_ID mappings (distance=1): EFO_IDs: %d, DO_IDs: %d", 
        uniqueN(efo2do_gwas[distance==1, efo_id]), uniqueN(efo2do_gwas[distance==1, do_id]))
sprintf("GWAS EFO_ID to DO_ID mappings (distance=2): EFO_IDs: %d, DO_IDs: %d", 
        uniqueN(efo2do_gwas[distance==2, efo_id]), uniqueN(efo2do_gwas[distance==2, do_id]))
knitr::kable(efo2do_gwas[sample(1:nrow(efo2do_gwas), 10)], caption="EBI OXO EFO-DOID (sample)")
```

# GENE-TRAIT stats

Read gt_stats.tsv, built by gwax_gt_stats.R for GWAX. Statistics designed to weigh evidence aggregated across
studies, for each gene-trait association.


```{r}
gt <- read_delim(gt_statsfile, "\t", col_types=cols(.default=col_character(), 
            n_study=col_integer(), n_snp=col_integer(), n_traits_g=col_integer(), n_genes_t=col_integer(), 
            pvalue_mlog_median=col_double(), or_median=col_double()))
setDT(gt)
sprintf("nrow(gt) = %d", nrow(gt))
```

### Focus on traits with more data and evidence, likely high scientific interest.

```{r}
gt_top <- gt[, .(trait_ids = paste(sub("^.*/", "", unique(trait_uri)), collapse=", "), N_genes=uniqueN(gsymb)), by="trait"]
knitr::kable(gt_top[order(-N_genes)][1:12], caption="Most-highly studied traits")
```

# Prototype GWAX web app.

## Plot single trait with all associated genes.

* X-axis: Evidence (`n_study`)
* Y-axis: Effect (`median(OR)`)
* Other considerations:
 * `n_traits_this_gene` - Normally prefer low value, but depends on other traits, semantics/ontology.
 * `n_snp` - How many SNPs? But is more or fewer better?
 * `pval_median` - Interpretation may be a challenge.
* Note/issue: Ignoring beta values because not comparable, due to varying units. (But maybe can be aggregated if units agree.)

Color unmapped gray.

Plot for a selected trait:

```{r}
#trait_id <- "EFO_0001360" #T2DM
#trait_id <- "EFO_0000249" #Alzheimer
#trait_id <- "EFO_0000289" #bipolar disorder
#trait_id <- "EFO_0000249" #Alzheimers disease
#trait_id <- "EFO_0000305" #breast carcinoma
#trait_id <- "EFO_0000270" #asthma
#trait_id <- "EFO_0000692" #schizophrenia
#trait_id <- "EFO_0005842" #colorectal cancer
#trait_id <- "EFO_0001663" #prostate carcinoma
#trait_id <- "EFO_0000685" #rheumatoid arthritis
#trait_id <- "EFO_0003761" #unipolar depression
trait_id <- "EFO_0002508" #Parkinsons disease
#trait_id <- "EFO_0001645" #coronary heart disease
#trait_id <- "EFO_0003885" #multiple sclerosis
#trait_id <- "EFO_0000384" #Crohns disease
#trait_id <- "EFO_0004574" #total cholesterol measurement

query_uri <- paste0("http://www.ebi.ac.uk/efo/", trait_id)
query_trait <- gt$trait[gt$trait_uri==query_uri][1]
sprintf("%s: %s", query_uri, query_trait)
```

### Pareto filter 

Selects N non-dominated solutions on 2D multi-objective boundary.

```{r}
pareto_filter <- function(dt, col_a, col_b, n) {
  if (nrow(dt) < n) { return(dt[, ok := T]) }
  dt$ok <- F
  n_ok_previous <- 0
  # Include non-dominated solutions up to (n).
  while (sum(dt$ok) < n) {
    if (sum(!dt$ok)==0) { break } #None left -- should not happen.
    i_notok <- which(!dt$ok)
    for (i in i_notok) {
      a <- dt[[col_a]][i]
      b <- dt[[col_b]][i]
      if (sum((!dt$ok) & (dt[[col_a]]>a) & (dt[[col_b]]>b), na.rm=T)==0) {
        dt[i]$ok <- T
        break
      }
    }
    if (sum(dt$ok)==n_ok_previous) { break } #No more -- should not happen.
    n_ok_previous <- sum(dt$ok)
  }
  return(dt)
}
```

### Filter for (1) Evidence (n_study) and (2) effect (or_median).

```{r}
t2g <- gt[trait_uri==query_uri]
t2g <- t2g[!is.na(gsymb)]
t2g <- t2g[!is.na(or_median)]
#t2g[, specificity := (1/n_traits_g)]
NMAX_PLOT <- 100
t2g <- pareto_filter(t2g, "or_median", "n_study", NMAX_PLOT)
message(sprintf("Pareto filter result: %d / %d", sum(t2g[, ok]), nrow(t2g)))
```

### Plot

```{r}
t2g[is.na(tdl), tdl := "NA"]
t2g$tdl <- factor(t2g$tdl, levels=c("Tclin", "Tchem", "Tbio", "Tdark", "NA"), ordered=T)
t2g[, markersize := 15/n_traits_g]
t2g[, text := paste0(gsymb, "<br>", name, "<br>", "Family: ", fam, "<br>", "TDL: ", tdl, "<br>", "n_traits_this_gene=", n_traits_g, " ; n_snp=", n_snp, " ; n_study=", n_study, " ; pval_median=", sprintf("%.2g",10^(-pvalue_mlog_median)))]
plot_ly(type='scatter', mode='markers', data=t2g[(ok)], 
  color=~tdl, colors=c("blue", "green", "red", "black", "gray"),
	x=~n_study + rnorm(sum(t2g$ok), sd=.05), #Custom jitter
	y=~or_median, marker=list(symbol="circle", size=~markersize), text=~text) %>%
  layout(xaxis=list(type="log", title="Evidence (N_study)"), 
         yaxis=list(type="log", title="Effect (OddsRatio)"), 
        title=paste0("GWAX: ", query_trait, "<br>(Trait_ID: ", sub('^.*/', '', query_uri), ")"),
        margin=list(t=100,r=50,b=60,l=60), legend=list(x=.75, y=.9), showlegend=T, font=list(family="monospace", size=18)) %>%
  add_annotations(text=sprintf("N_gene = %d (%d shown)", nrow(t2g), sum(t2g$ok)), showarrow=F, x=0.1, y=1.0, xref="paper", yref="paper")
```

Top hits:

```{r}
setorder(t2g, -n_study, -rcras, -or_median, pvalue_mlog_median)
knitr::kable(t2g[(ok)][1:10][, .(gsymb, name, fam, tdl, n_study, rcras, or_median, pvalue_mlog_median)], caption=sprintf("GWAX: %s, top hits", query_trait))
```

