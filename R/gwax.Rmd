---
title: "GWAS Explorer (GWAX)"
author: "Jeremy Yang"
output:
  html_document:
    number_sections: yes
    toc: yes
---

# Introduction

Genome wide association studies (GWAS) can reveal important genotype to phenotype associations, however, data quality and interpretability issues must be addressed.  The GWAX approach enables rational filtering and interpretation of GWAS via metrics, methods, and interactive visualization.  Each GWAS association is evaluated, using a continuous numerical scale, for confidence and specificity linking a protein-coding gene and clinical phenotype. Appropriate thresholds for various use cases are left to the judgement of users.

* Updated to [GWAS Catalog](https://www.ebi.ac.uk/gwas/) v1.0.2, Sept 30, 2018.
* Refactored workflow for integration with TCRD & Pharos
* Developed pipeline for iCite Relative Citation Ratio (RCR) integration
* Prototype RShiny app: <http://unmtid-shinyapps.net/gwax/>


```{r echo=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
base::date()
```

```{r warning=FALSE}
library(readr, quietly=T)
library(data.table, quietly=T)
library(plotly, quietly=T)
```

# Read files

From GWAS Catalog, TCRD, and EFO.

```{r}
ifile_gwas <- "data/gwascat_gwas.tsv"
ifile_assn <- "data/gwascat_assn.tsv"
ifile_snp2gene <- "data/gwascat_snp2gene.tsv"
ifile_trait <- "data/gwascat_trait.tsv"
ifile_icite <- "data/gwascat_icite.tsv"
ifile_tcrd <- "data/tcrd_targets.csv"
ifile_efo <- "data/efo.tsv"
gt_statsfile <- "data/gt_stats.tsv"
gwas <- read_delim(ifile_gwas, "\t", col_types=cols(.default=col_character(), 
    DATE=col_date(format="%Y-%m-%d"), DATE_ADDED_TO_CATALOG=col_date(format="%Y-%m-%d"),
    ASSOCIATION_COUNT=col_integer()))
setDT(gwas)
assn <- read_delim(ifile_assn, "\t", col_types=cols(.default=col_character(), 
    DATE=col_date(format="%Y-%m-%d"), DATE_ADDED_TO_CATALOG=col_date(format="%Y-%m-%d")))
setDT(assn)
snp2gene <- read_delim(ifile_snp2gene, "\t", col_types=cols(.default=col_character(),
    REPORTED_OR_MAPPED=col_factor(c("r","m","md","mu"))))
setDT(snp2gene)
trait <- read_delim(ifile_trait, "\t", col_types=cols(.default=col_character()))
setDT(trait)
tcrd <- read_csv(ifile_tcrd, col_types=cols(.default=col_character()))
setDT(tcrd)
```

# Genome Wide Association Studies (GWAS)

### Counts by year

```{r}
sprintf("Studies total: %d ; accessions: %d ; traits: %d ; PMIDs: %d", nrow(gwas), uniqueN(gwas$STUDY_ACCESSION), uniqueN(gwas$DISEASE_TRAIT), uniqueN(gwas$PUBMEDID))
gwas[, `:=`(YEAR = format(DATE,"%Y"), PLATFORM = sub("[, ].*$", "", `PLATFORM_[SNPS_PASSING_QC]`))]
gwas_counts <- gwas[, .(.N), by=c("YEAR", "PLATFORM")]
setorder(gwas_counts, YEAR, PLATFORM)
plot_ly(type="bar", data=gwas_counts[, .(N_gwas = sum(N)), by=YEAR], x=~YEAR, y=~N_gwas) %>%
  layout(title="GWAS Catalog Counts", 
         margin=list(t=120), font=list(family="monospace", size=18)) %>%
  add_annotations(text=sprintf("N_study = %d", nrow(gwas)), showarrow=F, x=0.1, y=1.0, xref="paper", yref="paper")
```
### Laboratory platforms

Grouped by vendor (first in list if multiple), though technologies may have evolved for a given
vendor.

```{r}
gwas_counts <- dcast(gwas_counts, YEAR ~ PLATFORM, value.var="N", fill=0)
plot_ly(gwas_counts, x=~YEAR, y=~NR, name="NR",
                type="scatter", mode="markers", fill="tonexty") %>%
  add_trace(y = ~Perlegen, name="Perlegen") %>%
  add_trace(y = ~Affymetrix, name="Affymetrix") %>%
  add_trace(y = ~Illumina, name="Illumina") %>%
  layout(title = 'GWAS counts by year &amp; vendor',
         xaxis = list(title="", showgrid=F),
         yaxis = list(title="N_study", showgrid=F),
         margin = list(t=100, l=100),
         font = list(family="monospace", size=18),
         legend = list(x=.1, y=.9), showlegend=T)
```

### Journals

```{r}
gwas_counts <- gwas[, .(N_gwas = .N, N_pmid = uniqueN(PUBMEDID), N_assn = sum(ASSOCIATION_COUNT)), by="JOURNAL"]
setorder(gwas_counts, -N_gwas)
knitr::kable(gwas_counts[1:12], caption="Top journals by N_gwas")
```



# Associations (SNP to trait)

```{r}
sprintf("Associations total: %d ; SNPs: %d ; traits: %d ; PMIDs: %d", nrow(assn), uniqueN(assn$SNPS), uniqueN(assn$DISEASE_TRAIT), uniqueN(assn$PUBMEDID))
```


# SNP to gene mappings

* `GSYMB`, `MAPPED_GENE` fields may include chromosomal locations or be "intergenic".
* Chromosomal locations (LOC*) may be non-coding RNA, etc.
* Mappings within gene stronger associations than upstream or downstream.

```{r}
sprintf("snp2gene: total associations: %d ; studies: %d ; snps: %d ; genes: %d ; intergenic associations: %d ; chromosomal location associations: %d",
        nrow(snp2gene), uniqueN(snp2gene$STUDY_ACCESSION), uniqueN(snp2gene$SNP), 
        uniqueN(snp2gene[!grepl("^LOC", GSYMB) & GSYMB != "intergenic", .(GSYMB)]),
        nrow(snp2gene[GSYMB=="intergenic"]), nrow(snp2gene[grepl("^LOC", GSYMB)]))
snp2gene[, REPORTED_OR_MAPPED := sub('^r$', 'reported', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^m$', 'mapped_within', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^mu$', 'mapped_upstream', REPORTED_OR_MAPPED)]
snp2gene[, REPORTED_OR_MAPPED := sub('^md$', 'mapped_downstream', REPORTED_OR_MAPPED)]
snp2gene_counts <- snp2gene[, .(.N), by="REPORTED_OR_MAPPED"]
knitr::kable(snp2gene_counts)
```


# Gene counts


```{r}
names(trait) <- c("STUDY_ACCESSION","TRAIT","TRAIT_URI")
trait <- trait[!is.na(trait$TRAIT_URI)]
trait$TRAIT <- iconv(trait$TRAIT, from="latin1", to="UTF-8")
trait[, trait_id := sub("^.*/", "", TRAIT_URI)]
sprintf("Studies: %d", uniqueN(assn$STUDY_ACCESSION))
sprintf("MAPPED_GENE values: %d", uniqueN(assn$MAPPED_GENE))
gsyms_tcrd <- unique(tcrd$protein_sym)
sprintf("TCRD targets: %d ; geneSymbols: %d", nrow(tcrd), length(gsyms_tcrd))
gsyms_gwax <- unique(snp2gene$GSYMB)
gsyms_common <- intersect(gsyms_gwax, gsyms_tcrd)
sprintf("GSYMBs mapped to TCRD: %d", length(gsyms_common))
tcrd <- merge(tcrd, data.table(gsym=gsyms_gwax, in_gwascat=rep(T, length(gsyms_gwax))),
	by.x="protein_sym", by.y="gsym", all.x=T, all.y=F)
tcrd$in_gwascat[is.na(tcrd$in_gwascat)] <- F
tcrd$idg2 <- as.logical(tcrd$idg2)
t2 <- table(tcrd$tdl[tcrd$in_gwascat])
sprintf("%s: %d", names(t2), t2)
```

# Gene-SNP-Study-Trait (G2T) associations

g2t should have one row for each gene-snp-study-trait association.

```{r}
g2t <- unique(snp2gene[, .(GSYMB, SNP, STUDY_ACCESSION)])
g2t <- merge(g2t, assn[, .(SNPS, STUDY_ACCESSION, PVALUE_MLOG, OR_or_BETA, oddsratio, beta)], 
	all.x=T, all.y=F, by.x=c("SNP", "STUDY_ACCESSION"), by.y=c("SNPS", "STUDY_ACCESSION"))

g2t <- merge(g2t, trait, all.x=F, all.y=F, by="STUDY_ACCESSION", allow.cartesian=T)
g2t <- g2t[!is.na(GSYMB)]
g2t <- g2t[!is.na(OR_or_BETA)]
g2t <- g2t[!grepl("(^LOC|^intergenic)", GSYMB)]

sprintf("GTs with pvalue_mlog, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$PVALUE_MLOG),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$PVALUE_MLOG)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$PVALUE_MLOG)]))
sprintf("GTs with or_or_beta, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$OR_or_BETA),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$OR_or_BETA)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$OR_or_BETA)]))
sprintf("GTs with oddsratio, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$oddsratio),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$oddsratio)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$oddsratio)]))
sprintf("GTs with beta, g2t: %d ; genes: %d ; traits: %d",
	 nrow(g2t[!is.na(g2t$beta),]),
	 uniqueN(g2t$GSYMB[!is.na(g2t$beta)]),
	 uniqueN(g2t$TRAIT[!is.na(g2t$beta)]))
```

# Traits and EFO

EFO = Experimental Factor Ontology. Includes Orphanet, PO, Mondo and Uberon classes.
TSV from source OWL. 

Can we aggregate evidence via EFO subclass links?

```{r warning=FALSE}
efo <- read_delim(ifile_efo, "\t", col_types=cols(.default=col_character()))
setDT(efo)
efo_classes <- efo[node_or_edge=="node"][, `:=`(node_or_edge=NULL, source=NULL, target=NULL)]
sprintf("EFO total classes: %d", uniqueN(efo_classes$uri))
efo_classes[, in_gwascat := as.logical(uri %in% trait$TRAIT_URI)]
efo_counts <- efo_classes[, Ontology := sub("_.*$", "", id)][, .(N_in_gwas = sum(in_gwascat), N_total = .N), by=Ontology][order(-N_in_gwas)]
knitr::kable(efo_counts[1:5], caption="EFO sources, top 5")
```


## GWAS trait-subclass relationships 

```{r}
efo_sub <- efo[node_or_edge=="edge"][, `:=`(node_or_edge=NULL, id=NULL, comment=NULL, uri=NULL)]
sprintf("EFO classes: %d ; total subclass relationships: %d", uniqueN(efo$uri), nrow(efo_sub))
efo_sub[, source_in_gwas := (source %in% trait$trait_id)]
efo_sub[, target_in_gwas := (target %in% trait$trait_id)]
efo_sub <- efo_sub[(source_in_gwas) & (target_in_gwas)]
efo_sub[, `:=`(source_in_gwas=NULL, target_in_gwas=NULL, label=NULL)]
setnames(efo_sub, old=c("source", "target"), new=c("trait_id", "subclass_id"))
trait_counts <- trait[, .(N_gwas = .N), by=c("trait_id", "TRAIT")]
efo_sub <- merge(efo_sub, trait_counts[, .(trait_id, trait_N_gwas=N_gwas, trait_name=TRAIT)], by.x="trait_id", by.y="trait_id", all.x=T, all.y=F)
efo_sub <- merge(efo_sub, trait_counts[, .(trait_id, subclass_N_gwas=N_gwas, subclass_name=TRAIT)], by.x="subclass_id", by.y="trait_id", all.x=T, all.y=F)
efo_sub <- efo_sub[, .(trait_id, trait_name, subclass_id, subclass_name, trait_N_gwas, subclass_N_gwas)]
sprintf("GWAS trait-subclass pairs: %d", nrow(efo_sub))
setorder(efo_sub, -trait_N_gwas, -subclass_N_gwas)
knitr::kable(efo_sub[1:24], caption="Top EFO trait-subclass pairs")
```

# GENE-TRAIT stats

Read gt_stats.tsv, built by gwax_gt_stats.R for GWAX. Statistics designed to weigh evidence aggregated across
studies, for each gene-trait association.

```{r}
gt <- read_delim(gt_statsfile, "\t", col_types=cols(.default=col_character(), 
            n_study=col_integer(), n_snp=col_integer(), n_traits_g=col_integer(), n_genes_t=col_integer(), 
            pvalue_mlog_median=col_double(), or_median=col_double()))
setDT(gt)
sprintf("nrow(gt) = %d", nrow(gt))
```

### Focus on traits with more data and evidence, likely high scientific interest.

```{r}
gt_top <- gt[, .(trait_ids = paste(sub("^.*/", "", unique(trait_uri)), collapse=", "), N_genes=uniqueN(gsymb)), by="trait"]
knitr::kable(gt_top[order(-N_genes)][1:12], caption="Most-highly studied traits")
```

# Prototype GWAX in trait-mode.

Plot single trait with all associated genes.

* X-axis: Evidence (`n_study`)
* Y-axis: Effect (`median(OR)`)
* Other considerations:
 * `n_traits_this_gene` - Normally prefer low value, but depends on other traits, semantics/ontology.
 * `n_snp` - How many SNPs? But is more or fewer better?
 * `pval_median` - Interpretation may be a challenge.


Color unmapped gray.

Plot for a selected trait:

```{r}
trait_id <- "EFO_0001360" #T2DM
#trait_id <- "EFO_0000249" #Alzheimer
#trait_id <- "EFO_0000289" #bipolar disorder
#trait_id <- "EFO_0000249" #Alzheimers disease
#trait_id <- "EFO_0000305" #breast carcinoma
#trait_id <- "EFO_0000270" #asthma
#trait_id <- "EFO_0000692" #schizophrenia
#trait_id <- "EFO_0005842" #colorectal cancer
#trait_id <- "EFO_0001663" #prostate carcinoma
#trait_id <- "EFO_0000685" #rheumatoid arthritis
#trait_id <- "EFO_0003761" #unipolar depression
#trait_id <- "EFO_0002508" #Parkinsons disease
#trait_id <- "EFO_0001645" #coronary heart disease
#trait_id <- "EFO_0003885" #multiple sclerosis
#trait_id <- "EFO_0000384" #Crohns disease

query_uri <- paste0("http://www.ebi.ac.uk/efo/", trait_id)
query_trait <- gt$trait[gt$trait_uri==query_uri][1]
sprintf("%s: %s", query_uri, query_trait)
```

## Pareto filter selects N non-dominated solutions on 2D multi-objective boundary.

```{r}
pareto_filter <- function(dt, a, b, n) {
  #How to pass cols as params?
  dt[, ok := F]
  n_ok_previous <- 0
  message(sprintf("DEBUG: max(%s) = %f ; max(%s) = %f ; N = %d", "or_median", max(dt[, or_median]), "n_study", max(dt[, n_study]), n))
  while (sum(dt[, ok]) < n) {
    if (nrow(dt[(!ok)])==0) {
      break
    }
    amax <- max(dt[(!ok), or_median])
    bmax <- max(dt[(!ok), n_study])

    dt[(!ok) & (or_median==amax)][order(-n_study)][1]$ok <- T
    dt[(!ok) & (n_study==bmax)][order(-or_median)][1]$ok <- T
    
    #message(sprintf("DEBUG: n_ok=%d ; n_ok_previous=%d", sum(dt[, ok]), n_ok_previous))
    if (sum(dt[, ok])==n_ok_previous) {
      break
    }
    n_ok_previous <- sum(dt[, ok])
  }
  return(dt)
}
```

### Filter for (1) Evidence (n_study) and (2) effect (or_median).

```{r}
t2g <- gt[trait_uri==query_uri]
t2g <- t2g[!is.na(gsymb)]
t2g <- t2g[!is.na(or_median)]
#t2g[, specificity := (1/n_traits_g)]
NMAX_PLOT <- 400
t2g <- pareto_filter(t2g, "or_median", "n_study", NMAX_PLOT)
message(sprintf("Pareto filter result: %d / %d", sum(t2g[, ok]), nrow(t2g)))
```

## Plot

```{r}
t2g[is.na(tdl), tdl := "NA"]
t2g$tdl <- factor(t2g$tdl, levels=c("Tclin", "Tchem", "Tbio", "Tdark", "NA"), ordered=T)
#t2g[, markersize := 5*log(pvalue_mlog_median+1)]
t2g[, markersize := 15/n_traits_g]
t2g[, text := paste0(gsymb, "<br>", name, "<br>", "Family: ", fam, "<br>", "TDL: ", tdl, "<br>", "n_traits_this_gene=", n_traits_g, " ; n_snp=", n_snp, " ; n_study=", n_study, " ; pval_median=", 10^(-pvalue_mlog_median))]
plot_ly(type='scatter', mode='markers', data=t2g[(ok)], 
  color=~tdl, colors=c("blue", "green", "red", "black", "gray"),
	x=~n_study + rnorm(sum(t2g$ok), sd=.05), #Custom jitter
	y=~or_median, marker=list(symbol="circle", size=~markersize), text=~text) %>%
  layout(xaxis=list(type="log", title="Evidence (n_study)"), 
         yaxis=list(type="log", title="Effect (median(OR))"), 
        title=paste0("GWAX: ", query_trait, "<br>(GWASCatalog TRAIT: ", sub('^.*/', '', query_uri), ")"),
        margin=list(t=100,r=50,b=60,l=60), legend=list(x=.75, y=.9), showlegend=T, font=list(family="monospace", size=18)) %>%
  add_annotations(text=sprintf("N_gene = %d (%d shown)", nrow(t2g), sum(t2g$ok)), showarrow=F, x=0.1, y=1.0, xref="paper", yref="paper")
```

